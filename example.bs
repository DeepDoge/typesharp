// my language

type None
type Error = {
    export type message = string
}

func foo(n: i64): i64 | None | Error => {
    if (n == 0) {
        return None
    }
    if (n < 0) {
        return Error { message: "n must be positive" }
    }
    return n * 2
}

type Foo = {
    export type foo = i64
}

type Bar = {
    export type bar = i64
}

type Baz = {
    export type baz = i64
}

type FooBar = Foo & Bar
type FooBarBaz = FooBar & Baz

Foo &= {
    export func createFoo(n: i64): Foo => {
        return Foo { foo: n }
    }
}

Bar &= {
    export func createBar(n: i64): Bar => {
        return Bar { bar: n }
    }
}

Baz &= {
    export func createBaz(n: i64): Baz => {
        return Baz { baz: n }
    }
}

FooBar &= {
    export func createFooBar(n: i64): FooBar => {
        return FooBar { foo: n, bar: n }
    }
}

FooBarBaz &= {
    export func createFooBarBaz(n: i64): FooBarBaz => {
        return FooBarBaz { foo: n, bar: n, baz: n }
    }
}

let foo = Foo.createFoo(1)
let bar = Bar.createBar(2)
let baz = Baz.createBaz(3)
let foobar = FooBar.createFooBar(4)
let foobarbaz = FooBarBaz.createFooBarBaz(5)

foobarbaz is Foo // true
foobarbaz is Bar // true
foobarbaz is Baz // true
foobarbaz is FooBar // true
foobarbaz is FooBarBaz // true

type Number = i8 | i16 | i32 | i64 | u8 | u16 | u32 | u64 | f32 | f64
Number |= uBig | iBig

type Vector3(T: Number) = {
    export type x = T
    export type y = T
    export type z = T
}

abstract type Shape(T: Number) = {
    export func area(self: ref Self): T
}

type Circle(T: Number) = {
    export type radius = T
}

Circle(T) &= Shape(T) {
    export func area(self: ref Circle(T)): T => {
        return 3.14 * self.radius * self.radius
    }
}

type Rectangle(T: Number) = {
    export type width = T
    export type height = T
}

Rectangle(T) &= Shape(T) {
    export func area(self: ref Rectangle(T)): T => {
        return self.width * self.height
    }
}

func printArea(shape: ref Shape) => {
    print(shape.area())
}

let a = 1: i64 // has type 1: i64
a++
a // has type 2: i64

let b = 1: i64 // has type 1: i64

let c = a + b // has type 3: i64

a += userInputI64()
a // has type i64

func foo(a: i64 | i32) => {
    if (a is i64) return "a is i64"
    if (a is i32) return "a is i32"
    a // has type never
}

let a = foo(1: i64) // a has type "a is i64"
let b = foo(1: i32) // b has type "a is i32"

let c = foo(userInputI64OrI32()) // c has type "a is i64" | "a is i32"

if (c is "a is i64") {
    c // has type "a is i64"
} else if (c is "a is i32") {
    c // has type "a is i32"
}

func foo(a: unknown) => {
    if (a is i64) return "a is i64"
    if (a is i32) return "a is i32"
    a // has type unknown
    return "a is unknown"
}

let a = foo(1: i64) // a has type "a is i64"
let b = foo(1: i32) // b has type "a is i32"

abstract type Number = {
    export const ZERO: Self // Self type is only available in abstract types, for now, might change my mind
}

i64 &= Number {
    export const ZERO = 0
}

i32 &= Number {
    export const ZERO = 0
}

Number // has type i64 | i32
i64 // has type i64 & Number

func add(a: T: Number, b: T): T => {
    return a + b
}

as seen above, abstract types can be used as unions based on what they are implemented by

func mightError(): i64 | Error => {
    if (userInputI64() == 0) {
        return Error { message: "user input was 0" }
    }
    return userInputI64()
}

let a = mightError()
if (a is Error) return a
a += 69

let a = mightError()! // a has type i64, it returns the error if it is one
let a = mightError()!! // a has type i64, it panics if it is an error

let a = {
    export let x = 1
    export let y = 2
} // a has anonymous type { x: i64, y: i64 }

let a = {
    return 1: i64
} // a has type 1: i64

let a = {
    let x = userInputI64()
    export let xx = x * x
    if (x == 0) return -1 // if we return early, retuned value is returned
    export let y = x * 2 

    // if we reach to the end of the block, structure of exports is retuned
} // a has type { xx: i64, y: i64 } | -1: i64 // by default number literals are i64, float literals are f64



type Foo = {
    export type foo = i64
}

let fooish = {
    export let foo = 1
    export let bar = 2
}: Foo // equivalent of satisfying interface
// fooish has type Foo & { bar: i64 }

so we do
fooish is Foo // true
fooish is { bar: i64 } // syntax error because type check is not pattern matching, or signature matching,

but you can do
func foo(a: { export let bar = i64 }) => {
    return a.bar
}



let x: Foo | Bar | Baz = ...

let y = match (typeof x) {
    Foo => x.foo
    Bar => x.bar
    Baz => x.baz
}

// we have IntPtr, this is for pointer integer based on the system architecture (32 or 64 bit) etc. it starts from 0
// types are IntPtr


usage of unknown can change based on the context

func foo(a: unknown) => {
    if (a is i64) return "a is i64"
    if (a is i32) return "a is i32"
    a // has type unknown
    return "a is unknown"
}

// above we determine what unknown is based where we call it from. if we call it from a place where we know it is i64, then it is i64

let a = foo(1: i64) // a has type "a is i64" // and compile code doesnt even have the if statements

but if we call it from a place where we dont know what it is, then it is unknown

let a = foo(userInputI64OrI32()) // a has type "a is i64" | "a is i32"
unions share the same structure, so size of a union is the size of the biggest type in the union
also there is a 1 byte tag to determine which type it is on runtime

but if we truly get something unkonwn, such as raw bytes from a file, then it is really unknown
let a = foo(readFile("foo.txt")) // a has type "a is unknown" | "a is i64" | "a is i32"
if we truly dont know what it is like this, we do the type check based on the size of the value


but we can also use unknown for generics
func foo(a: T: unknown): T => {
    return a
}

btw you know we have these blocks 

let a = {
    let n = 1
    export let x = n * n
    export let y = n * 2
} // a has anonymous type { x: i64, y: i64 }

and same with types as well 

type Foo = {
    type n = 1
    export type x = n * n
    export type y = n * 2
}

so we can also do this

func foo(a: T, b: { 
    if (T is i64) {
        return type x = { export let i64 = T }
    } else if (T is i32) {
        return type x = { export let i32 = T }
    }
    return T
 }) => {
    return b
} // so based on the type of a, b changes, but its not like in ts, we really have a block here, and we can do anything we want in it

also there are shorthands

type Vector3(T: Number) = {
    export type x = T
    export type y = T
    export type z = T
}

would be the same as

type Vector3(T: Number) = {
    x = T
    y = T
    z = T
} // so if after the first word in the block, there is a =, then the whole block is a shorthand block

same for variables

let a = {
    let x = 1
    let y = 2
}

would be the same as

let a = {
    x = 1
    y = 2
}


let position: Vector3(i64) = {
    x = 1
    y = 2
    z = 3
}

type Foo = {
    a = 1 | 2 | 3
}

type Bar = {
    a = 4 | 5 | 6
}

let value: Foo | Bar = ...

if (value.a == 1) {
    value // has type Foo
} else if (value.a == 4) {
    value // has type Bar
}